---
description: Guidelines for implementing embedding-based vector storage for semantic representation and retrieval.
globs: lmm_project/utils/vector_store.py, lmm_project/storage/*.py
alwaysApply: true
---
# LMM Vector Storage Guidelines

Vector storage is essential for semantic memory and retrieval in the LMM system. These guidelines ensure efficient and consistent implementation of embedding-based storage.

## Core Components

- **Embeddings**: Vector representations of concepts, experiences, etc.
- **Vector Store**: Efficient storage and retrieval system
- **Index**: Data structure for similarity search
- **Metadata**: Additional information associated with vectors

## Implementation Requirements

- Use FAISS for efficient similarity search
- Implement appropriate index types based on vector characteristics
- Configure GPU acceleration when available
- Support both exact and approximate nearest neighbor search
- Implement serialization and deserialization for persistence
- Create metadata storage alongside vectors

## Embedding Generation

- Use the LLM API at "http://192.168.2.12:1234/v1/embeddings"
- Implement batched embedding generation for efficiency
- Standardize vector dimensions (typically 768 or 1536)
- Normalize embeddings when appropriate
- Cache frequently used embeddings

## FAISS Configuration

- Use IndexFlatL2 for small datasets (exact search)
- Use IndexIVFFlat or similar for larger datasets (approximate search)
- Implement CUDA acceleration when available:
```python
if faiss.get_num_gpus() > 0:
    res = faiss.StandardGpuResources()
    index = faiss.index_cpu_to_gpu(res, 0, index)
```
- Configure appropriate training for IVF indices
- Set proper nprobe values for search quality vs. speed tradeoff

## Search Operations

- Implement k-nearest neighbors search
- Support filtered search based on metadata
- Implement thresholded search (similarity above threshold)
- Create hybrid search capabilities (vector + keyword)
- Support batch search operations

## Persistence Strategy

- Save indices to disk for persistence
- Implement metadata serialization
- Create backup and versioning mechanisms
- Support incremental updates
- Implement index optimization during save/load

## Memory Efficiency

- Monitor memory usage for large indices
- Implement dimension reduction techniques when necessary
- Use efficient metadata storage
- Support index sharding for very large collections
- Implement cleanup for unused embeddings