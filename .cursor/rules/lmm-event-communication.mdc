---
description: Guidelines for implementing the event-based communication system that enables modules to interact.
globs: lmm_project/core/event_bus.py, lmm_project/core/message.py
alwaysApply: true
---
# LMM Event Communication Guidelines

The event communication system is the backbone of the LMM architecture, allowing independent modules to interact through a standardized messaging interface.

## Core Components

- **EventBus**: Central message routing system
- **Message**: Typed communication object
- **Subscribers**: Module callbacks for specific message types
- **Publishers**: Message sources (typically modules)

## Message Structure

All messages must include:
- **Sender**: ID of the originating module
- **Message Type**: Categorization of the message
- **Content**: Payload data (must be a valid Pydantic model or basic type)
- **Timestamp**: When the message was created
- **ID**: Unique identifier for the message

## Event Types and Standards

Common message types include:
- `perception_input`: New sensory input
- `attention_focus`: Focus change notification
- `memory_storage`: Memory created/updated
- `memory_retrieval`: Memory recall event
- `emotion_update`: Emotional state change
- `consciousness_broadcast`: Global workspace update
- `development_milestone`: Developmental progress

## Implementation Requirements

- Use strict typing for all messages with Pydantic validation
- Support both synchronous and asynchronous message handling
- Implement message history with configurable size
- Create publisher-subscriber pattern for loose coupling
- Ensure thread-safety for concurrent processing
- Implement message filtering capabilities
- Support prioritization for urgent messages

## Debugging and Monitoring

- Create logging for all message activity
- Implement message visualization tools
- Support message replay for debugging
- Add tracing capabilities for message chains
- Create message statistics reporting

## Performance Considerations

- Optimize message routing for high throughput
- Implement batching for high-frequency messages
- Use efficient serialization for message content
- Avoid bottlenecks in central event processing
- Consider distributed event processing for scaling