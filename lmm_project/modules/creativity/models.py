from pydantic import BaseModel, Field, model_validator
from typing import Dict, List, Any, Optional, Set, Union, Tuple
from datetime import datetime
import uuid
import numpy as np

class Concept(BaseModel):
    """Representation of a concept in the creative system"""
    concept_id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    name: str
    features: Dict[str, Any] = Field(default_factory=dict)
    associations: List[str] = Field(default_factory=list)  # IDs of related concepts
    source: str = "unknown"
    creation_time: datetime = Field(default_factory=datetime.now)
    
    model_config = {
        "arbitrary_types_allowed": True
    }

class ConceptCombinationState(BaseModel):
    """State for the concept combination component"""
    combinations: Dict[str, Dict[str, Any]] = Field(default_factory=dict)  # Maps combination_id to combination data
    combination_patterns: Dict[str, float] = Field(default_factory=dict)  # Maps pattern types to usage frequency
    recent_combinations: List[str] = Field(default_factory=list)  # IDs of recent combinations
    concept_cache: Dict[str, Concept] = Field(default_factory=dict)  # Cached concepts for faster access
    
    model_config = {
        "arbitrary_types_allowed": True
    }

class DivergentThinkingState(BaseModel):
    """State for the divergent thinking component"""
    solution_spaces: Dict[str, Dict[str, Any]] = Field(default_factory=dict)  # Maps problem_id to solution space
    fluency_score: float = Field(default=0.1, ge=0.0, le=1.0)  # Ability to generate many ideas
    flexibility_score: float = Field(default=0.1, ge=0.0, le=1.0)  # Ability to generate diverse ideas
    originality_score: float = Field(default=0.1, ge=0.0, le=1.0)  # Ability to generate novel ideas
    elaboration_score: float = Field(default=0.1, ge=0.0, le=1.0)  # Ability to develop ideas in detail
    
    model_config = {
        "arbitrary_types_allowed": True
    }

class ImaginationState(BaseModel):
    """State for the imagination component"""
    scenes: Dict[str, Dict[str, Any]] = Field(default_factory=dict)  # Maps scene_id to scene data
    active_scene: Optional[str] = None  # ID of currently active scene
    scene_complexity: float = Field(default=0.1, ge=0.0, le=1.0)  # Complexity level of generated scenes
    coherence_level: float = Field(default=0.3, ge=0.0, le=1.0)  # How coherent the scenes are
    novelty_level: float = Field(default=0.5, ge=0.0, le=1.0)  # How novel the scenes are
    
    model_config = {
        "arbitrary_types_allowed": True
    }

class NoveltyDetectionState(BaseModel):
    """State for the novelty detection component"""
    novelty_thresholds: Dict[str, float] = Field(default_factory=dict)  # Thresholds for different input types
    recently_processed: List[Dict[str, Any]] = Field(default_factory=list)  # Recent inputs for baseline
    novelty_scores: Dict[str, float] = Field(default_factory=dict)  # Maps item_id to novelty score
    surprise_sensitivity: float = Field(default=0.5, ge=0.0, le=1.0)  # Sensitivity to unexpected inputs
    
    model_config = {
        "arbitrary_types_allowed": True
    }

class CreativeOutput(BaseModel):
    """A creative output generated by the system"""
    output_id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    content: Dict[str, Any]
    output_type: str  # Type of creative output (concept, scene, solution, etc.)
    novelty_score: float = Field(default=0.5, ge=0.0, le=1.0)
    coherence_score: float = Field(default=0.5, ge=0.0, le=1.0)
    usefulness_score: float = Field(default=0.5, ge=0.0, le=1.0)
    source_components: List[str] = Field(default_factory=list)  # Components that contributed
    creation_time: datetime = Field(default_factory=datetime.now)
    
    model_config = {
        "arbitrary_types_allowed": True
    }

class CreativityMetrics(BaseModel):
    """Metrics tracking various aspects of creativity performance"""
    fluency: float = Field(default=0.0, ge=0.0, le=1.0)  # Ability to generate many ideas
    flexibility: float = Field(default=0.0, ge=0.0, le=1.0)  # Ability to generate diverse ideas
    originality: float = Field(default=0.0, ge=0.0, le=1.0)  # Novelty of generated ideas
    elaboration: float = Field(default=0.0, ge=0.0, le=1.0)  # Detail in generated ideas
    coherence: float = Field(default=0.0, ge=0.0, le=1.0)  # How well ideas fit together
    usefulness: float = Field(default=0.0, ge=0.0, le=1.0)  # Practical value of ideas
    last_updated: datetime = Field(default_factory=datetime.now)
    
    model_config = {
        "arbitrary_types_allowed": True
    }

class CreativityState(BaseModel):
    """Integrated state of the creativity system"""
    concept_combination: ConceptCombinationState = Field(default_factory=ConceptCombinationState)
    divergent_thinking: DivergentThinkingState = Field(default_factory=DivergentThinkingState)
    imagination: ImaginationState = Field(default_factory=ImaginationState)
    novelty_detection: NoveltyDetectionState = Field(default_factory=NoveltyDetectionState)
    
    # Overall creativity metrics
    fluidity: float = Field(default=0.1, ge=0.0, le=1.0)  # Ability to flow between ideas
    originality: float = Field(default=0.1, ge=0.0, le=1.0)  # Overall originality of outputs
    elaboration: float = Field(default=0.1, ge=0.0, le=1.0)  # Detail and richness of outputs
    abstraction: float = Field(default=0.1, ge=0.0, le=1.0)  # Ability to work with abstract concepts
    
    # Detailed creativity metrics
    metrics: Optional[CreativityMetrics] = Field(default=None)
    
    # Output history
    output_history: List[CreativeOutput] = Field(default_factory=list)
    
    # Developmental level of creativity
    developmental_level: float = Field(default=0.0, ge=0.0, le=1.0)
    
    # Recent creative outputs
    recent_outputs: List[CreativeOutput] = Field(default_factory=list)
    
    # Time tracking
    last_update: datetime = Field(default_factory=datetime.now)
    
    model_config = {
        "arbitrary_types_allowed": True
    }
    
    @model_validator(mode='after')
    def update_creativity_metrics(self):
        """Update overall creativity metrics based on component states"""
        # Fluidity combines divergent thinking fluency and imagination coherence
        self.fluidity = (
            self.divergent_thinking.fluency_score * 0.6 +
            self.imagination.coherence_level * 0.4
        ) * (0.5 + 0.5 * self.developmental_level)
        
        # Originality combines divergent thinking originality and imagination novelty
        self.originality = (
            self.divergent_thinking.originality_score * 0.5 +
            self.imagination.novelty_level * 0.5
        ) * (0.5 + 0.5 * self.developmental_level)
        
        # Elaboration combines divergent thinking elaboration and imagination complexity
        self.elaboration = (
            self.divergent_thinking.elaboration_score * 0.5 +
            self.imagination.scene_complexity * 0.5
        ) * (0.5 + 0.5 * self.developmental_level)
        
        # Abstraction is derived from concept combination complexity
        pattern_complexity = sum(self.concept_combination.combination_patterns.values()) / max(1, len(self.concept_combination.combination_patterns))
        self.abstraction = pattern_complexity * (0.5 + 0.5 * self.developmental_level)
        
        return self
